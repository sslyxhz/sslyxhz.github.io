---
title: JNI参数传递
date: 2018-02-03 17:23:10
category: [notes]
tags: [jni]
---

JNI参数传递。

<!-- more -->

# JNI类型映射
基础数据类型直接映射，如Java中的int映射成jint。基本数据类型在java和native之间采用值传递。

引用类型以一种不透明的引用方式向原生代码传递对象，不透明的引用指的是，指向Java虚拟机中内部数据对象的C语言指针，原生代码必须通过JNIEnv中定义的函数处理这些内部数据对象。java对象采用引用传递。

所有的JNI引用都是jobject类型。

虚拟机必须保持已传递给native对象的引用，以便这些对象不被垃圾回收期回收。native code也必须有一种方法通知虚拟机它不再需要某个对象，并且垃圾收集器必须能够将其回收。

# UTF-8编码

JNI使用改进的UTF-8字符串来表示不同的字符类型。Java使用UTF-16编码。UTF-8编码主要使用于C语言，因为它的编码用\u000表示为0xc0，而不是通常的0×00。非空ASCII字符改进后的字符串编码中可以用一个字节表示。

# 局部引用
- 范围：传入native方法的所有参数，以及大多数JNI函数返回的对象都是局部引用。

- 生存期：本地函数返回后，即使这个对象仍然存活，但是这个引用也是无效的。这种情况适用于jobject的子类，包括jclass、jstring、jarray。

- 释放：局部引用在方法调用时有效，在方法调用结束之后自动释放，但有几种情况应当显式进行局部引用的释放：

  1. 方法中创建了一个比较大的java对象的，并持有其局部引用，使用完之后，如果接下来都不再需要使用了，如果仍然不对它进行释放的话，在方法结束之前，这个对象都不会进行释放，这样会对资源造成浪费
  2. JNI会将创建的局部引用都存储在一个局部引用表中，如果这个表超过了最大容量限制，就会造成局部引用表溢出，使程序崩溃。比如在一个循环中创建局部引用，最好在每一轮循环中释放局部引用，否则随着循环次数增加，很可能就内存溢出了

- 限制：局部引用仅仅在其创建的线程内有效，native代码不能跨线程传递局部引用。

# 全局引用
- 获取：获取全局引用的唯一方法，通过调用函数NewGlobalRef。

- 生存期：全局引用保持有效，直到被显式释放。

jfield和jmethod是透明类型，不是对象类型，没有必要传入到NewGlobalRef函数里，它们本身是不变的。

GetStringUtfChars和GetByteArrayElements函数返回的原始数据指针，也不是对象，也就可以在线程间传递。

# 弱全局引用
- 获取：获取若全局引用的唯一办法，通过调用函数NewWEakGlobalRef。

- 区别：弱全局引用和全局引用的区别是，弱全局引用持有的java对象可以被VM回收。因此在使用弱全局引用前要先进行检测是否被回收了。